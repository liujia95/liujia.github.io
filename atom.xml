<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuJia&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/liujia95/liujia95.github.io/"/>
  <updated>2018-11-15T08:24:00.834Z</updated>
  <id>https://github.com/liujia95/liujia95.github.io/</id>
  
  <author>
    <name>Liu Jia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android | jni调用c++/c详解</title>
    <link href="https://github.com/liujia95/liujia95.github.io/2018/07/07/Android-use-jni-invoking-c-plus-plus-and-c/"/>
    <id>https://github.com/liujia95/liujia95.github.io/2018/07/07/Android-use-jni-invoking-c-plus-plus-and-c/</id>
    <published>2018-07-07T05:57:53.000Z</published>
    <updated>2018-11-15T08:24:00.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><p>1、下载ndk<br>2、编写jni的加载类<br>3、使用javah -jni生成.h文件<a id="more"></a><br>4、准备好c/c++源代码文件<br>5、编写Application.mk和Android.mk文件<br>6、编写app.gradle<br>7、用ndk-build命令编译成so库<br>8、android载入so并调用方法<br>9、扩展<br>9.1、如何在C++源码里打印log到android studio的logcat上</p><hr><p>开发环境：<br>macbook pro 2017<br>android studio 3.0.1</p><h3 id="1、下载ndk"><a href="#1、下载ndk" class="headerlink" title="1、下载ndk"></a>1、下载ndk</h3><p><img src="https://upload-images.jianshu.io/upload_images/2237943-d815ac3491195bcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="2、编写jni的加载类"><a href="#2、编写jni的加载类" class="headerlink" title="2、编写jni的加载类"></a>2、编写jni的加载类</h3><p>参考例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">append</span><span class="params">(String str1, String str2)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"JniTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上append方法就是要调用c++/c中的方法。<br>JniTest是在Android.mk里约束好的，关于Android.mk的编写具体在后面详解。</p><h3 id="3、使用javah-jni生成-h文件"><a href="#3、使用javah-jni生成-h文件" class="headerlink" title="3、使用javah -jni生成.h文件"></a>3、使用javah -jni生成.h文件</h3><p>编写好jni加载类之后，就要开始生成.h文件了，此文件相当于一个声明文件，起到jni连接c++源代码的桥梁作用（我猜的）。<br>具体步骤：<br>part1：编译项目，生成.class文件，打开android studio 的Terminal工具，cd 到app/build/intermediates/classes/debug目录下，输入命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -jni 包名.JniTest</span><br></pre></td></tr></table></figure></p><p>part2：然后你会看到app/build/intermediates/classes/debug目录下多出了一个(包名_JniTest.h)文件，将其拷贝到app/src/main/jni目录下，这一步就算完成了。</p><h3 id="4、准备好c-c-源代码文件"><a href="#4、准备好c-c-源代码文件" class="headerlink" title="4、准备好c/c++源代码文件"></a>4、准备好c/c++源代码文件</h3><p>参考例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_dengdeng_dengdeng_test_JniTest_append</span><br><span class="line">    (JNIEnv * env, jobject obj, jstring jstr1, jstring jstr2)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str1,*str2;</span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="keyword">int</span> len1,len2;</span><br><span class="line">    jstring jresult;</span><br><span class="line">    str1 = (*env)-&gt;GetStringUTFChars(env,jstr1,<span class="literal">NULL</span>);</span><br><span class="line">    str2 = (*env)-&gt;GetStringUTFChars(env,jstr2,<span class="literal">NULL</span>);</span><br><span class="line">    len1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    result = <span class="built_in">malloc</span>((len1+len2)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(result,str1);</span><br><span class="line">    <span class="built_in">strcpy</span>(result+len1,str2);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env,jstr1,str1);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env,jstr2,str2);</span><br><span class="line">    jresult = (*env)-&gt;NewStringUTF(env,result);</span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="keyword">return</span> jresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将c/c++源码放入app/src/main/jni目录下即可。</p><h3 id="5、编写Application-mk和Android-mk文件"><a href="#5、编写Application-mk和Android-mk文件" class="headerlink" title="5、编写Application.mk和Android.mk文件"></a>5、编写Application.mk和Android.mk文件</h3><p>参考例子：<br>Application.mk：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的ndk库函数版本号。一般和SDK的版本相对应，各个版本在NDK目录下的platforms文件夹中</span></span><br><span class="line">APP_PLATFORM := android-14</span><br><span class="line"><span class="comment"># 编译成什么类型的cpu的so, 拥有三个属性armeabi  armeabi-v7a  x86可以全选 也可以只用一个，如果全选也可以使用all</span></span><br><span class="line">APP_ABI :=all</span><br><span class="line">APP_STL:=stlport_static</span><br></pre></td></tr></table></figure></p><p>Android.mk：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"><span class="comment">#需要修改输出.so文件的名字字段——本字段和上文的设置相对应。</span></span><br><span class="line">LOCAL_MODULE := JniTest</span><br><span class="line"><span class="comment">#需要修改src文件名</span></span><br><span class="line">LOCAL_SRC_FILES := jnitest.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure></p><p>以上两个文件存放至app/src/main/jni下，这一步就算完成了。</p><h3 id="6、编写app-gradle"><a href="#6、编写app-gradle" class="headerlink" title="6、编写app.gradle"></a>6、编写app.gradle</h3><p>参考例子<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ndk &#123; <span class="comment">//设置支持的SO库架构（开发者可以根据需要，选择一个或多个平台的so）</span></span><br><span class="line">      abiFilters <span class="string">"armeabi"</span>, <span class="string">"armeabi-v7a"</span>, <span class="string">"x86"</span>,<span class="string">"arm64-v8a"</span>,  <span class="string">"arm64-v8a"</span>, <span class="string">"x86_64"</span></span><br><span class="line">      moduleName <span class="string">"JniTest"</span></span><br><span class="line">      ldLibs <span class="string">"EGL"</span>,<span class="string">"GLESv3"</span>,<span class="string">"dl"</span>,<span class="string">"log"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">sourceSets</span>.main &#123;</span><br><span class="line">      jni.srcDirs = []<span class="comment">//disable automatic ndk-build call</span></span><br><span class="line">      jniLibs.srcDir <span class="string">"src/main/libs"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7、用ndk-build命令编译成so库"><a href="#7、用ndk-build命令编译成so库" class="headerlink" title="7、用ndk-build命令编译成so库"></a>7、用ndk-build命令编译成so库</h3><p>打开Terminal，cd到app/src/main/jni，输入命令：ndk-build即可生成对应的so，这一步比较简单，不做赘述。</p><h3 id="8、android载入so并调用方法"><a href="#8、android载入so并调用方法" class="headerlink" title="8、android载入so并调用方法"></a>8、android载入so并调用方法</h3><p>参考例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JniTest jni = <span class="keyword">new</span> JniTest();</span><br><span class="line">String result = jni.append(<span class="string">"abc"</span>, <span class="string">"123"</span>);</span><br></pre></td></tr></table></figure></p><p>直接调用就可以了</p><h3 id="9、扩展"><a href="#9、扩展" class="headerlink" title="9、扩展"></a>9、扩展</h3><h5 id="9-1、如何在C-源码里打印log到android-studio的logcat上"><a href="#9-1、如何在C-源码里打印log到android-studio的logcat上" class="headerlink" title="9.1、如何在C++源码里打印log到android studio的logcat上"></a>9.1、如何在C++源码里打印log到android studio的logcat上</h5><p>一共三部分<br>part1：在c++源码头部添加以下代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入log头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="comment">// log标签</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  TAG <span class="meta-string">"DDManchesterWAV"</span></span></span><br><span class="line"><span class="comment">// 定义info信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__)</span></span><br><span class="line"><span class="comment">// 定义debug信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="comment">// 定义error信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__)</span></span><br></pre></td></tr></table></figure></p><p>part2：在Android.mk增加一行<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_LDLIBS:=-L<span class="variable">$(SYSROOT)</span>/usr/lib -llog</span><br></pre></td></tr></table></figure></p><p>part3：在c++源码里打印log<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGE(<span class="string">"原始数据 --&gt; byte[%d] value: %d"</span>,i,voice_data[i]);</span><br></pre></td></tr></table></figure></p><p>以下就是logcat打印出的效果：<br><img src="https://upload-images.jianshu.io/upload_images/2237943-22cf36c7a0e5ebf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="logcat打印出c++log的效果.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录：&quot;&gt;&lt;a href=&quot;#目录：&quot; class=&quot;headerlink&quot; title=&quot;目录：&quot;&gt;&lt;/a&gt;目录：&lt;/h3&gt;&lt;p&gt;1、下载ndk&lt;br&gt;2、编写jni的加载类&lt;br&gt;3、使用javah -jni生成.h文件
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/liujia95/liujia95.github.io/tags/Android/"/>
    
      <category term="jni" scheme="https://github.com/liujia95/liujia95.github.io/tags/jni/"/>
    
  </entry>
  
  <entry>
    <title>Android | ConstraintLayout</title>
    <link href="https://github.com/liujia95/liujia95.github.io/2017/11/01/Android-widget-ConstraintLayout/"/>
    <id>https://github.com/liujia95/liujia95.github.io/2017/11/01/Android-widget-ConstraintLayout/</id>
    <published>2017-11-01T02:44:00.000Z</published>
    <updated>2018-11-15T09:15:59.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><p>1、为什么要用ConstraintLayout<br>2、ConstraintLayout有哪些缺点<br>3、怎么使用ConstraintLayout<a id="more"></a>  </p><hr><h3 id="1、为什么要用ConstraintLayout？"><a href="#1、为什么要用ConstraintLayout？" class="headerlink" title="1、为什么要用ConstraintLayout？"></a>1、为什么要用ConstraintLayout？</h3><p>1、任何复杂的布局只需一层（除非有嵌套的事件响应需求）：</p><blockquote><p>绘制过程中的每个阶段都需要对视图树执行一次自顶向下的遍历操作。因此，视图层次结构中嵌入（或嵌套）的视图越多，设备绘制视图所需的时间和计算功耗也就越多。通过在 Android 应用布局中保持扁平的层次结构，您可以为应用创建响应快速而灵敏的界面。  </p></blockquote><p>2、性能更出色  </p><blockquote><p>ConstraintLayout 在测量/布局阶段的性能比 RelativeLayout大约高 40%。<br>详情参阅：<a href="https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ" target="_blank" rel="noopener">解析ConstraintLayout的性能优势</a></p></blockquote><p>3、LinearLayout和RecyclerView的布局能做到的ConstraintLayout都能做到，它们做不到的也能做到（这一点后面详解）。</p><h3 id="2、它有哪些缺点？"><a href="#2、它有哪些缺点？" class="headerlink" title="2、它有哪些缺点？"></a>2、它有哪些缺点？</h3><p>1、xml很啰嗦</p><blockquote><p>主要体现在两方面：</p><ul><li>它需要通过详尽的属性来确定自身位置，因为以前用LL或RL的写法，有些属性在父容器写一次就够，子容器就无需再写一次，但这个是每个容器都是独立的，需要根据周围的控件确定自身的位置。所以这就引出了第二个啰嗦。</li><li>每个View都要有与之对应的id。</li></ul></blockquote><p>2、没有gravity属性，这里后面会讲到一个“拉力”的概念，这里先简单说一下，怎么实现gravity=center这样的效果呢？需要把每个边都与父容器的边对应上（需设置4个属性），因为四个边都要拉扯以将控件拉到中间。</p><h3 id="3、怎么使用？"><a href="#3、怎么使用？" class="headerlink" title="3、怎么使用？"></a>3、怎么使用？</h3><h4 id="1、引入资源"><a href="#1、引入资源" class="headerlink" title="1、引入资源"></a>1、引入资源</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.android.support.constraint:constraint-layout:1.0.2'</span></span><br></pre></td></tr></table></figure><h4 id="2、熟悉它的属性，主要有几部分："><a href="#2、熟悉它的属性，主要有几部分：" class="headerlink" title="2、熟悉它的属性，主要有几部分："></a>2、熟悉它的属性，主要有几部分：</h4><h5 id="part1-类似于RelativeLayout的部分："><a href="#part1-类似于RelativeLayout的部分：" class="headerlink" title="part1:类似于RelativeLayout的部分："></a>part1:类似于RelativeLayout的部分：</h5><p>根据其他控件给自身定位：</p><blockquote><p>layout_toRightOf=”A”——&gt;layout_constraintLeft_toRightOf=”A”<br>根据父容器给自身定位：<br>layout_alignParentRight=true——&gt;layout_constraintRight_toRightOf=parent</p></blockquote><p>类似的还有：</p><blockquote><p>layout_constraintRight_toLeftOf<br>layout_constraintRight_toRightOf<br>layout_constraintTop_toTopOf<br>layout_constraintTop_toBottomOf<br>layout_constraintBottom_toTopOf<br>layout_constraintBottom_toBottomOf<br>//根据某控件的基线对齐<br>layout_constraintBaseline_toBaselineOf</p></blockquote><h5 id="part2：类似LinearLayout的weight效果"><a href="#part2：类似LinearLayout的weight效果" class="headerlink" title="part2：类似LinearLayout的weight效果"></a>part2：类似LinearLayout的weight效果</h5><p>官方有张图，如[图1]所示，通常来说，LinearLayout的weight只能实现第四行的效果，但ConstraintLayout可以实现下图全部。<br><img src="http://upload-images.jianshu.io/upload_images/2237943-0a0a5e059b072d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br>想实现类似LL（LinearLayout）的weight的效果，重点看每个TextView的最下三行以及每个TextView的<strong>layout_width都是0</strong>，以下布局可以实现三个TextView。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tab1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"30dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">"@+id/tab2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tab2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"30dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">"@id/tab1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">"@+id/tab3"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tab3"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"30dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">"@id/tab2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果想实现2：1：1等分的效果，就如[图1]的第四行，需要给<strong>每个</strong>TextView<strong>分别</strong>添加如下属性，并<strong>挨个</strong>设置值为2，1，1即可：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintHorizontal_weight</span><br></pre></td></tr></table></figure></p><h5 id="part3：以下是LinearLayout和RelativeLayout都做不到的，或者说是-要花很大的代价才能实现-。"><a href="#part3：以下是LinearLayout和RelativeLayout都做不到的，或者说是-要花很大的代价才能实现-。" class="headerlink" title="part3：以下是LinearLayout和RelativeLayout都做不到的，或者说是[要花很大的代价才能实现]。"></a>part3：以下是LinearLayout和RelativeLayout都做不到的，或者说是[要花很大的代价才能实现]。</h5><ul><li>1、先说一下【链（Chains）】的概念：  </li></ul><p>ConstraintLayout中的控件想要定位准确，A控件是要依赖于父容器左侧和B，然后B控件依赖于A和B，C依赖于B以及父容器的右侧，就如图2所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2237943-f4a23b94597e6e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.png"></p><p>这个链代表了某种约束和拉力，上图A，B，C之间存有<strong>间隙</strong>，（ps：如果要<strong>无</strong>间隙等分的话，需设置layout_width=0dp），图2每个控件拉力都是一样的，如果想实现[图1]的其他效果，实际上都是根据拉力大小变化来实现的，B拉力大一点，那A和C都更靠近B一点点，类似这样的道理。</p><p>这里要引出一个属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_chainStyle</span><br></pre></td></tr></table></figure></p><p>该属性有三个值：spread（铺开），spread_inside（里面铺开）， packed（拥挤），效果依次对应图1的：第1行，第2行，第4行。<br>默认是spread。（ps：以上效果layout_width是固定值或wrap_content，如果是0的话就会类似第3行那样）<br><img src="http://upload-images.jianshu.io/upload_images/2237943-0a0a5e059b072d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p><ul><li>2、用bias（偏斜）实现[图1]第5行的效果  </li></ul><p>简而言之就是调整C控件两边的拉力即可，对应的属性是：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_bias //水平线的拉力</span><br><span class="line">layout_constraintVertical_bias  //垂直线的拉力</span><br></pre></td></tr></table></figure></p><p>该属性的值是0~1，默认是0.5，通过调整水平线的拉力即可达到第5行的效果了。</p><ul><li>3、控件的宽高比  </li></ul><p>以前如果想要实现一个Banner宽高比是2:1这样的，很麻烦，因为每个机型分辨率有大有小，除非代码运行才能知道屏幕宽度是多少，才能动态得到屏幕宽度，在xml中根本无法实现。<br>但ConstraintLayout提供了一个属性就能实现：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintDimensionRatio="W,2:1"</span><br><span class="line">或</span><br><span class="line">app:layout_constraintDimensionRatio="H,1:2"</span><br></pre></td></tr></table></figure></p><p>注意：<strong>宽高需要设置0dp才能有效果！</strong></p><h5 id="part4：关于Guideline（辅助线）"><a href="#part4：关于Guideline（辅助线）" class="headerlink" title="part4：关于Guideline（辅助线）"></a>part4：关于Guideline（辅助线）</h5><p>这个是为了方便ConstraintLayout布局，如果用过CAD的朋友就应该知道辅助线，用来辅助画图很方便，而且保存文件的时候该线是不会显示到图片上的，同理，这个也只是在写xml的时候辅助用的，应用真正运行的时候是看不到的。</p><p>因为是一条线嘛，自然要区分水平还是垂直的，所以就有一个属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:orientation</span><br></pre></td></tr></table></figure></p><p>取值为”vertical”和”horizontal”，跟RecyclerView一样。</p><p>它还有一些属性用来给辅助线找准位置，然后给辅助线命名个id，其他控件只要基于该先找到自己的位置就好啦~<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintGuide_begin  </span><br><span class="line">layout_constraintGuide_end</span><br><span class="line">layout_constraintGuide_percent</span><br></pre></td></tr></table></figure></p><p>它有两种方式来找到自己的位置，一个是绝对值，也就是begin&amp;end（取值为dp），一个是百分比percent（取值为0~1）。<br>当orientation为vertical的时候，begin对应距离顶部，end对应距离底部。<br>当orientation为horizontal的时候，begin对应距离左边，end对应距离右边。</p><p>真正使用的时候，就把Guideline当作一个View来用好了，Android Studio也会有预览给你看的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录：&quot;&gt;&lt;a href=&quot;#目录：&quot; class=&quot;headerlink&quot; title=&quot;目录：&quot;&gt;&lt;/a&gt;目录：&lt;/h3&gt;&lt;p&gt;1、为什么要用ConstraintLayout&lt;br&gt;2、ConstraintLayout有哪些缺点&lt;br&gt;3、怎么使用ConstraintLayout
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/liujia95/liujia95.github.io/tags/Android/"/>
    
      <category term="控件" scheme="https://github.com/liujia95/liujia95.github.io/tags/%E6%8E%A7%E4%BB%B6/"/>
    
  </entry>
  
</feed>
